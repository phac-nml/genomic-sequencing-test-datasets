---
title: "Summary Report:ncovtools"
author: "`r Sys.info()['user']`"
date: "`r Sys.Date()`"
output: html_document
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = paste0("output/test_set/HTML/",Sys.Date(),"_report.html")) })
---

```{css, echo=FALSE}
h2,h3,{
  text-align: left;
}
h1,h4 {
  text-align: center;
}
```

```{r packages, include=FALSE}
########################### STEP 1 LOAD PACKAGES ########################### 
library(yaml) #Load profile configuration
library(here) #Access project root directory

r=getOption("repos")
r["CRAN"] = "http://cran.us.r-project.org"
options(repos = r)

#changed the way this is read in so that an absolute path is not needed in the script-the user opens the project with the script and we use the here() function to find the yaml file in the working directory. however, the yaml file will need the absolute path in the base path to be editied to where the file lives 
yaml_file_path <- here("Test_Illumina_Data/Illumina_C6/C6_config.yaml") #this should work to lead the user to the yaml file without an absolute path using projects
config <- yaml.load_file(yaml_file_path)

# Load packages
## This will print a message indicating which packages were loaded and will not print the list of packages multiple times (i.e not full list of packages once per package as seen with lapply)
## If any of the packages fail to load, an error will be generated by the library function. The following will check if all packages were loaded successfully and print a message for each package that is loaded successfully and will generate an error if any package could not be loaded. The stop function will halt the script and print the error message.

ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])] #function that installs packages needed for this to run
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
ipak(config$Packages)

packages_loaded <- sapply(config$Packages, function(pkg) {
  if(require(pkg, character.only = TRUE)) {
    message(paste0("Package '", pkg, "' was loaded successfully."))
    return(pkg)
  } else {
    stop(paste0("Package '", pkg, "' could not be loaded."))
  }
})

# Set the file path
base_path <- config$Base_path

# Construct the full paths using file.path
data_folder <- file.path(base_path, config$Data_folder)

# Set folders to compare (avoiding absolute path here for now)
Name_of_folder_one <- config$Name_of_folder_one
Name_of_folder_two <- config$Name_of_folder_two

# Find the nml_tree.nwk file in the folder
tree_f1_files <- list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_tree\\.nwk$", full.names = TRUE, recursive = TRUE)
if (length(tree_f1_files) == 0) stop("*_tree.nwk file not found in folder ", file.path(data_folder, Name_of_folder_one))
tree_f1_dend <- tree_f1_files[1]

tree_f2_files <- list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_tree\\.nwk$", full.names = TRUE, recursive = TRUE)
if (length(tree_f2_files) == 0) stop("*_tree.nwk file not found in folder ", file.path(data_folder, Name_of_folder_two))
tree_f2_dend <- tree_f2_files[1]


#Set the working directory
setwd(data_folder)

########################### loop through and make a list of ALL files in an ncovtools folder ########################### 
ambiguous_position_report <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_ambiguous_position_report\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_ambiguous_position_report\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(ambiguous_position_report) != 2) stop("Did not find a total of 2 ambiguous_position_report.tsv files in the input folders")

mixture_report <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_mixture_report\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_mixture_report\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(mixture_report) != 2) stop("Did not find a total of 2 mixture_report.tsv files in the input folders")

ncov_watch_variants <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_ncov_watch_variants\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_ncov_watch_variants\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(ncov_watch_variants) != 2) stop("Did not find a total of 2 ncov_watch_variants.tsv files in the input folders")

negative_control_report <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_negative_control_report\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_negative_control_report\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(negative_control_report) != 2) stop("Did not find a total of 2 negative_control_report.tsv files in the input folders")

summary_qc <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_summary_qc\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_summary_qc\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(summary_qc) != 2) stop("Did not find a total of 2 summary_qc.tsv files in the input folders")

qc.csv <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*\\.qc\\.csv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*\\.qc\\.csv$", full.names = TRUE, recursive = TRUE))
if (length(qc.csv) != 2) stop("Did not find a total of 2 *.qc.csv files in the input folders")


########################### make a list of the lists above, excluding base_path and data_folder (to work with Kimia downstream) ########################### 
###also want to remove the leading forward slash in the paths that populate list.of.files.1###
list.of.files.1<-list(
  sub("^/", "", sub(data_folder, "", ambiguous_position_report)),
  sub("^/", "", sub(data_folder, "", mixture_report)),
  sub("^/", "", sub(data_folder, "", ncov_watch_variants)),
  sub("^/", "", sub(data_folder, "", negative_control_report)),
  sub("^/", "", sub(data_folder, "", summary_qc))
)

list.of.files_qc<-list(sub("^/", "", sub(data_folder, "", qc.csv)))

#print(list.of.files.1)

#print(list.of.files_qc)


#fread is much faster/convenient than read.table (detection is automatic);
#simplify=false -->rbindlist from data.table, the id column now contains the filenames

#there were some issues with the col types not matching, so setting them will prevent errors binding
#make a function to select variables
setwd(data_folder)
for (i in seq_along(list.of.files.1)){
  dt.list.1 <- sapply(list.of.files.1[[i]], fread, simplify=FALSE)
}

for(i in list.of.files.1)
  {require(list.of.files.1)
  dt.list.1[i] <- sapply(paste0(i), fread, simplify=FALSE)
}

#make a function that converts column types
convert_column_types <- function(df_list, col_types) {
  # Apply the column types to each dataframe in the list
  df_list <- lapply(df_list, function(df) {
    # Convert the dataframe to a tibble to use the col_types
    df <- as_tibble(df)
    # Convert all columns to character first
    df <- df %>% mutate(across(everything(), as.character))
    # Apply the column types only to the columns that exist in the dataframe
    common_cols <- intersect(names(col_types$cols), names(df))
    df <- type_convert(df, col_types = cols(!!!col_types$cols[common_cols]))
    return(df)
  })
  
  return(df_list)
}

# Define the column types using column names
col_types <- cols(
  sample = col_character(),
  run_name = col_character(),
  run_identifier = col_logical(),
  num_consensus_snvs = col_integer(),
  num_consensus_n = col_integer(),
  num_consensus_iupac = col_integer(),
  num_variants_snvs = col_integer(),
  num_variants_indel = col_integer(),
  num_variants_indel_triplet = col_integer(),
  mean_sequencing_depth = col_number(),
  qpcr_ct = col_logical(),
  collection_date = col_logical(),
  num_weeks = col_logical(),
  scaled_variants_snvs = col_logical(),
  genome_completeness = col_number(),
  qc_pass = col_character(),
  lineage = col_character(),
  lineage_notes = col_character(),
  scorpio_call = col_character(),
  watch_mutations = col_character(),
  position = col_integer(),
  count = col_logical(),
  alleles = col_logical(),
  sample_a = col_logical(),
  sample_b = col_logical(),
  variants_checked = col_logical(),
  variants_mixed = col_logical(),
  read_support_allele_a = col_logical(),
  read_support_allele_b = col_logical(),
  mixture_fraction = col_logical(),
  mixed_sites = col_logical(),
  mutation = col_character(),
  contig = col_character(),
  reference = col_character(),
  alt = col_character(),
  file = col_character(),
  qc = col_character(),
  genome_covered_bases = col_character(),
  genome_total_bases = col_character(),
  genome_covered_fraction = col_character(),
  amplicons_detected = col_logical(),
  barcode = col_logical(),
  project_id = col_logical(),
  num_aligned_reads = col_integer(),
  variants = col_character(),
  protein_variants = col_character(),
  sequence_received_date = col_integer(),
  sequencing_technology = col_character(),
  snpeff_frameshift_consequence = col_logical(),
  diagnostic_primer_mutations = col_character(),
  sequencing_primer_mutations = col_character(),
  scheme = col_character(),
  version = col_character(),
  pangolin_note = col_character(),
  script_name = col_character(),
  revision = col_character(),
  next_flow_qc_pass = col_character()
)

dt.list.1 <- convert_column_types(dt.list.1, col_types)

# Combine the data tables into a single data table
DT.1 <- rbindlist(dt.list.1, idcol = 'id', fill = TRUE)


## identify number of columns to separate by / in id
ncols <- max(str_count(DT.1$id, "/")) + 1

##produce new columns that are separated by /
DT2<- cbind(DT.1,str_split_fixed(DT.1$id,"/",ncols))


      ##again for nmlqc
setwd(data_folder)
for (i in seq_along(list.of.files_qc)){
  dt.list.2 <- sapply(list.of.files_qc[[i]], fread, simplify=FALSE)
}
for(i in list.of.files_qc)
  {dt.list.2[i] <- sapply(paste0(i), fread, simplify=FALSE)
}

dt.list.2 <- convert_column_types(dt.list.2, col_types)

DT.2 <- rbindlist(dt.list.2, idcol = 'id',fill = TRUE)


# Combine the data tables into a single data table
DT.2 <- rbindlist(dt.list.2, idcol = 'id', fill = TRUE)



## identify number of columns to separate by / in id
ncols.2 <- max(str_count(DT.2$id, "/")) + 1

##produce new columns that are separated by /
DT2.2<- cbind(DT.2,str_split_fixed(DT.2$id,"/",ncols.2))


```

## Specific Files for analysis {.tabset}

#This is a summary report comparing `r length(unique(DT2$V1))` Runs: `r unique(DT2$V1)`.

### Files

#The following files under **ncovtools** will be compared in this report:

```{r folders, echo=FALSE}
###### Make table of files to that are read in
files<-as.data.frame(c(unique(DT2$V5),unique(DT2.2$V3))) 
files.as.table.format<-files %>% 
  rename(Files=1) %>%
  kable(row.names = TRUE) %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)

files.as.table.format
```

### Path description and levels for files

```{r directory structure,echo=FALSE, warning=FALSE,, fig.align='left'}
### Path description and levels for files


PATHS<-list.files(config$Base_path,
                  recursive = TRUE,
                  include.dirs = TRUE)
mytree <-data.tree::as.Node(data.frame(pathString = PATHS))
mytree
```

## Summary {.tabset}
------------------------------------------------------------------------

### Summary table:

#This table identifies matching and discrepant values between aggregated outputs based on sample identifiers on summary_qc file.

```{r summary_table, echo=FALSE, warning=FALSE}
DT3_1<-DT2 %>% 
  filter(V1==Name_of_folder_one) 
colnames(DT3_1)<-paste("1",colnames(DT3_1),sep = "_")
DT3_1<-DT3_1 %>% 
  rename(sample=`1_sample`) %>%
  filter(!is.na(sample))


DT3_2<-DT2 %>%
  filter(V1==Name_of_folder_two)
colnames(DT3_2)<-paste("2",colnames(DT3_2),sep = "_")
DT3_2<-DT3_2 %>% 
  rename(sample=`2_sample`) %>%
  filter(!is.na(sample))
  

DT3_full<-merge(DT3_1,DT3_2,by="sample",all.x = TRUE,allow.cartesian=TRUE)

## Matching datasets except those with blank sample column
DT4<-DT3_full %>% select(-`2_collection_date`,-`1_collection_date`)
DT4[is.na(DT4)]<-"N/A"

#"num_consensus_snvs"
DT4$`num_consensus_snvs`<-ifelse(
  DT4$`1_num_consensus_snvs`==DT4$`2_num_consensus_snvs`,
  "MATCH",
  "**FAILED**")

#"num_consensus_n"
DT4$`num_consensus_n`<-ifelse(
  DT4$`1_num_consensus_n`==DT4$`2_num_consensus_n`,
  "MATCH",
  "**FAILED**")

#"num_consensus_iupac"
DT4$`num_consensus_iupac`<-ifelse(
  DT4$`1_num_consensus_iupac`==DT4$`2_num_consensus_iupac`,
  "MATCH",
  "**FAILED**")

#"num_variants_snvs"
DT4$`num_variants_snvs`<-ifelse(
  DT4$`1_num_variants_snvs`==DT4$`2_num_variants_snvs`,
  "MATCH",
  "**FAILED**")

#"num_variants_indel"
DT4$`num_variants_indel`<-ifelse(
  DT4$`1_num_variants_indel`==DT4$`2_num_variants_indel`,
  "MATCH",
  "**FAILED**")

#"num_variants_indel"
DT4$`num_variants_indel`<-ifelse(
  DT4$`1_num_variants_indel`==DT4$`2_num_variants_indel`,
  "MATCH",
  "**FAILED**")

#"num_variants_indel_triplet"
DT4$`num_variants_indel_triplet`<-ifelse(
  DT4$`1_num_variants_indel_triplet`==DT4$`2_num_variants_indel_triplet`,
  "MATCH",
  "**FAILED**")

#"mean_sequencing_depth"
DT4$`mean_sequencing_depth`<-ifelse(
  DT4$`1_mean_sequencing_depth`==DT4$`2_mean_sequencing_depth`,
  "MATCH",
  "**FAILED**")

#"median_sequencing_depth"
DT4$`median_sequencing_depth`<-ifelse(
  DT4$`1_median_sequencing_depth`==DT4$`2_median_sequencing_depth`,
  "MATCH",
  "**FAILED**")

#"scaled_variants_snvs"
DT4$`scaled_variants_snvs`<-ifelse(
  DT4$`1_scaled_variants_snvs`==DT4$`2_scaled_variants_snvs`,
  "MATCH",
  "**FAILED**")

#"genome_completeness"
DT4$`genome_completeness`<-ifelse(
  DT4$`1_genome_completeness`==DT4$`2_genome_completeness`,
  "MATCH",
  "**FAILED**")

#"qc_pass"
DT4$`qc_pass`<-ifelse(
  DT4$`1_qc_pass`==DT4$`2_qc_pass`,
  "MATCH",
  "**FAILED**")

#"lineage"
DT4$`lineage`<-ifelse(
  DT4$`1_lineage`==DT4$`2_lineage`,
  "MATCH",
  "**FAILED**")

#"lineage_notes"
DT4$`lineage_notes`<-ifelse(
  DT4$`1_lineage_notes`==DT4$`2_lineage_notes`,
  "MATCH",
  "**FAILED**")

#"scorpio_call"
DT4$`scorpio_call`<-ifelse(
  DT4$`1_scorpio_call`==DT4$`2_scorpio_call`,
  "MATCH",
  "**FAILED**")

#"watch_mutations"
DT4$`watch_mutations`<-ifelse(
  DT4$`1_watch_mutations`==DT4$`2_watch_mutations`,
  "MATCH",
  "**FAILED**")
```

```{r table_1, echo=FALSE}
DT4_all<-DT4 %>%
    filter(grepl("qc", `1_V5`)) %>%
  select(sample,num_consensus_snvs,num_consensus_n,num_consensus_iupac,num_variants_snvs,num_variants_indel,
         num_variants_indel_triplet,mean_sequencing_depth,median_sequencing_depth,scaled_variants_snvs,
         genome_completeness,qc_pass,lineage,lineage_notes,scorpio_call,watch_mutations)
DT4_all[DT4_all=="MATCH"]<-"TRUE"
DT4_all[DT4_all=="**FAILED**"]<-"FALSE"

DT4_all<-DT4_all %>% convert(lgl(num_consensus_snvs,num_consensus_n,num_consensus_iupac,num_variants_snvs,num_variants_indel,num_variants_indel_triplet,mean_sequencing_depth,median_sequencing_depth,scaled_variants_snvs,genome_completeness,qc_pass,lineage,lineage_notes,scorpio_call,watch_mutations))
# identify the logical columns
boolCols <- sapply(DT4_all, is.logical)
# sum each row of the logical columns and
# compare to the total number of logical columns
DT4_all$all_data <- rowSums(DT4_all[,..boolCols]) == sum(boolCols)

DT4_all$all_data<-as.character(DT4_all$all_data)
DT4_all$all_data[DT4_all$all_data=="FALSE"]<-"**FAILED**"
DT4_all_plot<-DT4_all %>% 
  select(sample,all_data) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT4_all_plot
```

### Summary table_detail:

```{r table_1_indetail, echo=FALSE}
DT4_final<-DT4 %>% 
  filter(grepl("qc", `1_V5`)) %>%
  select(sample,num_consensus_snvs,num_consensus_n,num_consensus_iupac,num_variants_snvs,num_variants_indel,
         num_variants_indel_triplet,mean_sequencing_depth,median_sequencing_depth,scaled_variants_snvs,
         genome_completeness,qc_pass,lineage,lineage_notes,scorpio_call,watch_mutations) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT4_final
```

## Summary of controls:

```{r table_2, echo=FALSE}

DT5_1<-DT2 %>% 
  filter(grepl("negative", `V5`)) %>%
  filter(V1==Name_of_folder_one) %>%
  select(id,file,qc,genome_covered_bases,genome_total_bases,genome_covered_fraction,amplicons_detected,V1,V2)
colnames(DT5_1)<-paste("1",colnames(DT5_1),sep = "_")
DT5_1<-DT5_1 %>% 
  rename(file=`1_file`) 
DT5_2<-DT2 %>% 
  filter(grepl("negative", `V5`)) %>%
  filter(V1==Name_of_folder_two) %>%
  select(id,file,qc,genome_covered_bases,genome_total_bases,genome_covered_fraction,amplicons_detected,V1,V2)
colnames(DT5_2)<-paste("2",colnames(DT5_2),sep = "_")
DT5_2<-DT5_2 %>% 
  rename(file=`2_file`) 

DT5_full<-merge(DT5_1,DT5_2,by="file",all.x = TRUE,allow.cartesian=TRUE)

## Matching datasets except those with blank sample column
DT6<-DT5_full
DT6[is.na(DT6)]<-"N/A"

#"qc"
DT6$`qc`<-ifelse(
  DT6$`1_qc`==DT6$`2_qc`,
  "MATCH",
  "**FAILED**")
#"genome_covered_bases"
DT6$`genome_covered_bases`<-ifelse(
  DT6$`1_genome_covered_bases`==DT6$`2_genome_covered_bases`,
  "MATCH",
  "**FAILED**")
#"genome_total_bases"
DT6$`genome_total_bases`<-ifelse(
  DT6$`1_genome_total_bases`==DT6$`2_genome_total_bases`,
  "MATCH",
  "**FAILED**")
#"genome_covered_fraction"
DT6$`genome_covered_fraction`<-ifelse(
  DT6$`1_genome_covered_fraction`==DT6$`2_genome_covered_fraction`,
  "MATCH",
  "**FAILED**")
#"amplicons_detected"
DT6$`amplicons_detected`<-ifelse(
  DT6$`1_amplicons_detected`==DT6$`2_amplicons_detected`,
  "MATCH",
  "**FAILED**")

DT6_final<-DT6 %>%
  select(file,qc,genome_covered_bases,genome_total_bases,genome_covered_fraction,amplicons_detected) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT6_final

##use the extraoperator library to produce a table of True/false for the columns required to identify IF controls match
qc=DT6$`1_qc` %a==% DT6$`2_qc`
genome_covered_bases=DT6$`1_genome_covered_bases` %a==% DT6$`2_genome_covered_bases`
genome_total_bases=DT6$`1_genome_total_bases` %a==% DT6$`2_genome_total_bases`
amplicons_detected=DT6$`1_amplicons_detected` %a==% DT6$`2_amplicons_detected`
```

The negative controls in this analysis `r ifelse((('TRUE' %in% qc)==TRUE & ('TRUE' %in% genome_covered_bases)==TRUE & ('TRUE' %in% genome_total_bases)==TRUE & ('TRUE' %in% amplicons_detected)==TRUE),"pass qc","do NOT pass qc")`.

## Summary of watch variants:

```{r table_3, echo=FALSE}
DT7_1<-DT2 %>%
  filter(grepl("variants", `V5`)) %>%
  filter(V1==Name_of_folder_one) %>%
  select(sample,mutation,contig,position,reference,alt,V1,V2)%>%
  mutate(nuc_mut=paste0(reference,position,alt))
DT7_1<-aggregate(nuc_mut ~ sample, data = DT7_1, paste, collapse=",")
colnames(DT7_1)<-paste("1",colnames(DT7_1),sep = "_")
DT7_1<-DT7_1 %>% 
  rename(sample=`1_sample`) 

DT7_2<-DT2 %>% 
  filter(grepl("variants", `V5`)) %>%
  filter(V1==Name_of_folder_two) %>%
  select(sample,mutation,contig,position,reference,alt,V1,V2)%>%
  mutate(nuc_mut=paste0(reference,position,alt))
DT7_2<-aggregate(nuc_mut ~ sample, data = DT7_2, paste, collapse=",")
colnames(DT7_2)<-paste("2",colnames(DT7_2),sep = "_")
DT7_2<-DT7_2 %>% 
  rename(sample=`2_sample`) 

DT7_full<-merge(DT7_1,DT7_2,by="sample",all.x = TRUE,allow.cartesian=TRUE)

## Matching datasets except those with blank sample column
DT8<-DT7_full
#"amplicons_detected"
DT8$`nucleotide_mutations`<-ifelse(
  DT8$`1_nuc_mut`==DT8$`2_nuc_mut`,
  "MATCH",
  "**FAILED**")
DT8_final<-DT8 %>%
  select(sample,nucleotide_mutations) %>%
  rename(`samples identified with watch mutations`=sample,) %>%
  mutate(`samples identified with watch mutations` = (gsub("[.]variants[.]norm[.]vcf", "", `samples identified with watch mutations`))) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT8_final

```

## Summary of mixtures:

```{r table_4, echo=FALSE}
DT9_1<-DT2 %>% 
  filter(grepl("mixture", `V5`)) %>%
  filter(V1==Name_of_folder_one) %>%
  select(sample_a,sample_b,variants_checked,variants_mixed,read_support_allele_a,read_support_allele_b,mixture_fraction,mixed_sites,V1,V2)%>%
  mutate(sample_a_b=paste0(sample_a,"_",sample_b))
colnames(DT9_1)<-paste("1",colnames(DT9_1),sep = "_")
DT9_1<-DT9_1 %>% 
  rename(sample_a_sample_b=`1_sample_a_b`) 

DT9_2<-DT2 %>% 
  filter(grepl("mixture", `V5`)) %>%
  filter(V1==Name_of_folder_two) %>%
  select(sample_a,sample_b,variants_checked,variants_mixed,read_support_allele_a,read_support_allele_b,mixture_fraction,mixed_sites,V1,V2)%>%
  mutate(sample_a_b=paste0(sample_a,"_",sample_b))
colnames(DT9_2)<-paste("2",colnames(DT9_2),sep = "_")
DT9_2<-DT9_2 %>% 
  rename(sample_a_sample_b=`2_sample_a_b`) 

DT9_full<-merge(DT9_1,DT9_2,by="sample_a_sample_b",all = TRUE,allow.cartesian=TRUE)

## Matching datasets except those with blank sample column
DT10<-DT9_full
#"amplicons_detected"
DT10$`variants_checked`<-ifelse(
  DT10$`1_variants_checked`==DT10$`2_variants_checked`,
  "MATCH",
  "**FAILED**")
DT10$`variants_mixed`<-ifelse(
  DT10$`1_variants_mixed`==DT10$`2_variants_mixed`,
  "MATCH",
  "**FAILED**")
DT10$`read_support_allele_a`<-ifelse(
  DT10$`1_read_support_allele_a`==DT10$`2_read_support_allele_a`,
  "MATCH",
  "**FAILED**")
DT10$`read_support_allele_b`<-ifelse(
  DT10$`1_read_support_allele_b`==DT10$`2_read_support_allele_b`,
  "MATCH",
  "**FAILED**")
DT10$`mixture_fraction`<-ifelse(
  DT10$`1_mixture_fraction`==DT10$`2_mixture_fraction`,
  "MATCH",
  "**FAILED**")
DT10$`mixed_sites`<-ifelse(
  DT10$`1_mixed_sites`==DT10$`2_mixed_sites`,
  "MATCH",
  "**FAILED**")

DT10_final<-DT10 %>%
  select(sample_a_sample_b,variants_mixed,read_support_allele_a,read_support_allele_b,mixture_fraction,mixed_sites) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT10_final
```

## Output: {.tabset}

------------------------------------------------------------------------

### Standard deviation for numerical columns (summary_qc):

```{r summary_qc, echo=FALSE, warning=FALSE,fig.dim=c(8, 4), fig.align='left', out.width="100%"}
#####example summary_qc.tsv
summary_qc_DF1<- DT2 %>% filter(grepl("qc", `V5`))

# 1. Standard Deviation Plot of Numerical Variables
summary_qc_DF1_SD=summary_qc_DF1 %>% 
  group_by(sample) %>%
  summarize(num_consensus_snvs=sd(num_consensus_snvs),
            num_consensus_n=sd(num_consensus_n),
            num_consensus_iupac=sd(num_consensus_iupac),
            num_variants_snvs=sd(num_variants_snvs),
            num_variants_indel=sd(num_variants_indel),
            num_variants_indel_triplet=sd(num_variants_indel_triplet),
            mean_sequencing_depth=sd(mean_sequencing_depth),
            median_sequencing_depth=sd(median_sequencing_depth),
            scaled_variants_snvs=sd(scaled_variants_snvs),
            genome_completeness=sd(genome_completeness))

  #Data Wrangling and Heatplot
SD_heatmapplot<- summary_qc_DF1_SD %>% 
  gather(variable,value,-sample) %>%
  arrange(sample) %>%
  mutate(sample=factor(sample)) %>%
  ggplot(aes(variable, sample, fill= value)) + 
  geom_tile(color = "white" ) +
  geom_text(aes(label = value), color = "white", size = 2) +
  guides(fill = guide_colourbar(title = "Standard Deviation",
                                barheight = 0.5,
                                ticks = FALSE)) +
  labs(title="Plot of SD by sample",
       x ="summary_qc", y = "Sample") +
  theme_grey(base_size = 5)
SD_heatmapplot
```

### Heatmaps (summary_qc):

```{r heatmaps,echo=FALSE, warning=FALSE,fig.dim=c(20, 7), fig.align='left'}
    ##QC heatmap showing n=1
summary_qc_DF1_qcpass<-aggregate(summary_qc_DF1$qc_pass, 
                                     by = list(summary_qc_DF1$sample,summary_qc_DF1$qc_pass,summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_qcpass<-summary_qc_DF1_qcpass %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
qcheatmap<-ggplot(summary_qc_DF1_qcpass,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.1),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of QC by sample",
     x ="summary_qc", y = "Sample") +
    theme_grey(base_size = 15) #+ theme(aspect.ratio = 0.5)
qcheatmap
    ##lineage heatmap showing n=1
summary_qc_DF1_lineage<-aggregate(summary_qc_DF1$lineage, 
                                     by = list(summary_qc_DF1$sample,summary_qc_DF1$lineage,summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_lineage<-summary_qc_DF1_lineage %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
lineageheatmap<-ggplot(summary_qc_DF1_lineage,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.1),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of lineage by sample",
     x ="summary_qc", y = "Sample") +
    theme_grey(base_size = 15) #+ theme(aspect.ratio = 0.5)
lineageheatmap
    ##lineage notes heatmap showing n=1
summary_qc_DF1_lineagenotes<-aggregate(summary_qc_DF1$lineage_notes, 
                                     by = list(summary_qc_DF1$sample,
                                               summary_qc_DF1$lineage_notes,
                                               summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_lineagenotes<-summary_qc_DF1_lineagenotes %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
lineagenotesheatmap<-ggplot(summary_qc_DF1_lineagenotes,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.1),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",,
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of lineage notes by sample",
     x ="summary_qc", y = "Sample") +
    theme_grey(base_size = 15) #+ theme(aspect.ratio = 0.5)
lineagenotesheatmap
    ##scorpio showing n=1
summary_qc_DF1_scorpio<-aggregate(summary_qc_DF1$scorpio_call, 
                                     by = list(summary_qc_DF1$sample,
                                               summary_qc_DF1$scorpio_call,
                                               summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_scorpio<-summary_qc_DF1_scorpio %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
scorpioheatmap<-ggplot(summary_qc_DF1_scorpio,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.06),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of scorpio calls by sample",
     x ="summary_qc", y = "Sample") +
    theme_grey(base_size = 15) #+ theme(aspect.ratio = 0.5)
scorpioheatmap
```

```{r heatmaps2,echo=FALSE, warning=FALSE,fig.dim=c(20, 13), fig.align='left'}

##watch mutations showing n=1
summary_qc_DF1_watchmut<-aggregate(summary_qc_DF1$watch_mutations, 
                                     by = list(summary_qc_DF1$sample,
                                               summary_qc_DF1$watch_mutations,
                                               summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_watchmut<-summary_qc_DF1_watchmut %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
watchmutheatmap<-ggplot(summary_qc_DF1_watchmut,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.1),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of watch mutations by sample",
     x ="summary_qc", y = "Sample") +
  scale_x_discrete(guide = guide_axis(angle = 90))
watchmutheatmap

```

### VCF comparison (qc.csv):

```{r mutation_table,echo=FALSE, warning=FALSE,fig.dim=c(20, 13), fig.align='left'}
DT2.2.1<-DT2.2 %>% 
  filter(V1==Name_of_folder_one) %>%
  select(sample,variants,V1,V2)
colnames(DT2.2.1)<-paste("1",colnames(DT2.2.1),sep = "_")
DT2.2.1<-DT2.2.1 %>% 
  rename(sample=`1_sample`)

DT2.2.2<-DT2.2 %>% 
  filter(V1==Name_of_folder_two) %>%
  select(sample,variants,V1,V2)
colnames(DT2.2.2)<-paste("2",colnames(DT2.2.2),sep = "_")
DT2.2.2<-DT2.2.2 %>% 
  rename(sample=`2_sample`) 

DT2.2.full<-merge(DT2.2.1,DT2.2.2,by="sample",all.x = TRUE,allow.cartesian=TRUE)
DT2.2.full$`1_variant_split`<-(strsplit(DT2.2.full$`1_variants`,";"))
DT2.2.full$`2_variant_split`<-strsplit(DT2.2.full$`2_variants`,";")

`%notin%` <- Negate(`%in%`)
  for(i in 1:nrow(DT2.2.full)) {
    DT2.2.full$count_of_F1_variants_in_F2_variants[i]<-sum(unlist(DT2.2.full[[8]][i]) %in% unlist(DT2.2.full[[9]][i]),na.rm = TRUE)
    DT2.2.full$count_of_F1_variants_NOT_in_F2_variants[i]<-sum(unlist(DT2.2.full[[8]][i]) %notin% unlist(DT2.2.full[[9]][i]),na.rm = TRUE)
    DT2.2.full$totalF1[i]<-length(unlist((DT2.2.full[[8]][i])))
    DT2.2.full$count_of_F2_variants_in_F1_variants[i]<-sum(unlist(DT2.2.full[[9]][i]) %in% unlist(DT2.2.full[[8]][i]),na.rm = TRUE)
    DT2.2.full$count_of_F2_variants_NOT_in_F1_variants[i]<-sum(unlist(DT2.2.full[[9]][i]) %notin% unlist(DT2.2.full[[8]][i]),na.rm = TRUE)
    DT2.2.full$totalF2[i]<-length(unlist(DT2.2.full[[9]][i]))
    DT2.2.full$`% match`[i]<-((DT2.2.full$count_of_F1_variants_in_F2_variants[i]/DT2.2.full$totalF1[i])*100)
    }
 
#length(unlist(df[[8]][i]))

DT10_final<-DT2.2.full %>%
  select(sample,totalF1,totalF2,`% match`) %>%
  rename(!!Name_of_folder_one:=totalF1,
         !!Name_of_folder_two:=totalF2) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT10_final
```

### Phylogenetic comparison (qc_analysis):

```{r phylogenetic comparison,echo=FALSE, warning=FALSE,fig.dim=c(20, 7), fig.align='left'}
##as.dendrogram (tanglegram)
Tree_F1_dend<- read.dendrogram(tree_f1_dend)
Tree_F2_dend<- read.dendrogram(tree_f2_dend)
DL<-dendlist(Tree_F1_dend,Tree_F2_dend)

##compute alignment quality (lower value == good alignment quality)
DL2<- DL %>% 
  untangle() %>% 
  tanglegram(sort=TRUE) %>%
  set("labels_colors") 

entangl<-entanglement(DL2)
```

Entanglement for the above comparison is`r entangl` indicating `r ifelse(entangl=="0", "a perfect match", "noticible differences between same tips")`.

**END**






